{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/openforge/paymentFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport {AppStorage} from \"../shared/storage/structs/AppStorage.sol\";\nimport {IPoolRouter} from \"../shared/interfaces/IPoolRouter.sol\";\nimport {LibMeta} from \"../shared/libraries/LibMeta.sol\";\nimport {IERC20} from \"../shared/interfaces/IERC20.sol\";\nimport {IERC1155} from \"../shared/interfaces/IERC1155.sol\";\n//\n//\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ncontract PaymentFacet is ReentrancyGuard {\n    AppStorage internal s;\n\n    // payable 필요 없나?\n    function pay(uint payAmount) external payable returns (uint, uint) {\n        require(payAmount > 0.1 ether, \"LibPayment: payAmount too low\");\n\n        // pangearouter\n        IPoolRouter poolRouter = IPoolRouter(s.contracts[\"pangearouter\"]);\n\n        IPoolRouter.ExactInputSingleParams memory params = IPoolRouter\n            .ExactInputSingleParams({\n                tokenIn: address(0),\n                amountIn: payAmount,\n                amountOutMinimum: 1000,\n                pool: s.contracts[\"gcpool\"],\n                to: s.contracts[\"bank\"],\n                unwrap: false\n            });\n        \n        // msg.value to address this\n        payable(address(this)).transfer(msg.value);\n\n        //payable\n        poolRouter.exactInputSingle{value: payAmount}(params);\n\n        return (payAmount, block.number);\n    }\n    // 0xc07f5c3200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000dcf075580c225b20000000000000000000000009f8a222fd0b75239b32aa8a97c30669e5981db05000000000000000000000000e34f22cf55db5209ba6546701d408e5f58d8703f0000000000000000000000000000000000000000000000000000000000000000\n    function reFund(\n        address _sender,\n        uint reFundAmount\n    ) external nonReentrant returns (uint, uint) {\n        require(reFundAmount > 5 ether, \"LibPayment: reFundAmount too low\");\n\n        IPoolRouter poolRouter = IPoolRouter(s.contracts[\"pangearouter\"]);\n\n        IPoolRouter.ExactInputSingleParams memory params = IPoolRouter\n        // pangearouter 0x17Ac28a29670e637c8a6E1ec32b38fC301303E34\n        // gc token 0x999999999939ba65abb254339eec0b2a0dac80e9\n        // gc pool 0x9F8a222Fd0b75239B32Aa8a97C30669E5981dB05\n            .ExactInputSingleParams({\n                tokenIn: s.contracts[\"gctoken\"],\n                amountIn: reFundAmount,\n                amountOutMinimum: 10,\n                pool: s.contracts[\"gcpool\"],\n                to: _sender,\n                unwrap: true\n            });\n\n        poolRouter.exactInputSingle(params);\n\n        return (reFundAmount, block.number);\n    }\n\n    function itemBuy(\n        address _buyer,\n        uint _itemId,\n        uint _quantity,\n        uint _payAmount\n    ) external nonReentrant returns (uint, uint) {\n        IERC1155 item = IERC1155(s.contracts[\"item\"]);\n        uint itemPrice = s.items[_itemId].price * _quantity;\n\n        require(s.items[_itemId].price != 0, \"PaymentFacet: item not found\");\n        require(_payAmount >= itemPrice, \"PaymentFacet: payAmount too low\");\n\n        IPoolRouter poolRouter = IPoolRouter(s.contracts[\"pangearouter\"]);\n\n        IPoolRouter.ExactInputSingleParams memory params = IPoolRouter\n            .ExactInputSingleParams({\n                tokenIn: s.contracts[\"gctoken\"],\n                amountIn: _payAmount,\n                amountOutMinimum: 10,\n                pool: s.contracts[\"gcpool\"],\n                to: _buyer,\n                unwrap: true\n            });\n\n        poolRouter.exactInputSingle(params);\n\n        item.mint(_buyer, _itemId, _quantity, \"0x0\");\n\n        return (_payAmount, block.number);\n    }\n}\n"
    },
    "contracts/shared/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC1155 {\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n\n    function burn(address account, uint256 id, uint256 value) external;\n\n    function balanceOf(\n        address account,\n        uint256 id\n    ) external view returns (uint256);\n\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external;\n}\n"
    },
    "contracts/shared/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/shared/interfaces/IPoolRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.8.0;\n\n/// @notice pool router interface.\ninterface IPoolRouter {\n    struct ExactInputSingleParams {\n        address tokenIn; /// @dev the input token address. If tokenIn is address(0), msg.value will be wrapped and used as input token\n        uint256 amountIn; /// @dev The amount of input tokens to send\n        uint256 amountOutMinimum; /// @dev minimum required amount of output token after swap\n        address pool; /// @dev pool address to swap\n        address to; /// @dev address to receive\n        bool unwrap; /// @dev unwrap if output token is wrapped klay\n    }\n\n    struct ExactInputParams {\n        address tokenIn; /// @dev the token address to swap-in. If tokenIn is address(0), msg.value will be wrapped and used as input token\n        uint256 amountIn; /// @dev The amount of input tokens to send.\n        uint256 amountOutMinimum; /// @dev minimum required amount of output token after swap\n        address[] path; /// @dev An array of pool addresses to pass through\n        address to; /// @dev recipient of the output tokens\n        bool unwrap; /// @dev unwrap if output token is wrapped klay\n    }\n\n    struct ExactOutputSingleParams {\n        address tokenIn; /// @dev the input token address. If tokenIn is address(0), msg.value will be wrapped and used as input token\n        uint256 amountOut; /// @dev The amount of output tokens to receive\n        uint256 amountInMaximum; /// @dev maximum available amount of input token after swap\n        address pool; /// @dev pool address to swap\n        address to; /// @dev address to receive\n        bool unwrap; /// @dev unwrap if output token is wrapped klay\n    }\n\n    struct ExactOutputParams {\n        address tokenIn; /// @dev the token address to swap-in. If tokenIn is address(0), msg.value will be wrapped and used as input token\n        uint256 amountOut; /// @dev The amount of output tokens to receive\n        uint256 amountInMaximum; /// @dev  maximum available amount of input token after swap\n        address[] path; /// @dev An array of pool addresses to pass through\n        address to; /// @dev recipient of the output tokens\n        bool unwrap; /// @dev unwrap if output token is wrapped klay\n    }\n\n    /// @notice Swap amountIn of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as ExactInputSingleParams in calldata\n    function exactInputSingle(\n        ExactInputSingleParams calldata params\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Swap amountIn of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as ExactInputParams in calldata\n    function exactInput(\n        ExactInputParams calldata params\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as ExactOutputSingleParams in calldata\n    function exactOutputSingle(\n        ExactOutputSingleParams calldata params\n    ) external payable returns (uint256 amountIn);\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as ExactOutputParams in calldata\n    function exactOutput(\n        ExactOutputParams calldata params\n    ) external payable returns (uint256 amountIn);\n\n    /// @notice Recover mistakenly sent tokens\n    function sweep(\n        address token,\n        uint256 amount,\n        address recipient\n    ) external payable;\n}\n"
    },
    "contracts/shared/libraries/LibMeta.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nlibrary LibMeta {\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(\n            bytes(\n                \"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\"\n            )\n        );\n\n    function domainSeparator(\n        string memory name,\n        string memory version\n    ) internal view returns (bytes32 domainSeparator_) {\n        domainSeparator_ = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                getChainID(),\n                address(this)\n            )\n        );\n    }\n\n    function getChainID() internal view returns (uint256 id) {\n        assembly {\n            id := chainid()\n        }\n    }\n\n    function msgSender() internal view returns (address sender_) {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender_ := and(\n                    mload(add(array, index)),\n                    0xffffffffffffffffffffffffffffffffffffffff\n                )\n            }\n        } else {\n            sender_ = msg.sender;\n        }\n    }\n}\n"
    },
    "contracts/shared/storage/structs/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct User {\n    string name;\n    uint tokenId;\n    //equpiment\n    //inventory\n    //stats\n}\n\nstruct Item {\n    uint itemId;\n    uint price;\n}\n\nstruct AppStorage {\n    mapping(string => address) contracts;\n    mapping(address => User) users;\n    mapping(uint => Item) items;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}