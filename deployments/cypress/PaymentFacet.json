{
  "address": "0x4ED28CaA76a1875956cF4736256d329edF90d3bC",
  "abi": [
    {
      "inputs": [],
      "name": "ReentrancyGuardReentrantCall",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_buyer",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_itemId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_quantity",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_payAmount",
          "type": "uint256"
        }
      ],
      "name": "itemBuy",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "payAmount",
          "type": "uint256"
        }
      ],
      "name": "pay",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_sender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "reFundAmount",
          "type": "uint256"
        }
      ],
      "name": "reFund",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x1b1d0b09edf3d460db80b5d6aff904853d62e2ff38a75383b953a3bdf220550a",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x78D851386840d7F70A68F2fBa538f54EBE2A5d8E",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "502738",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xe2786073dbbf64b80f394f6c81718e61c2519f20ed6b39b6f124475f4930440d",
    "transactionHash": "0x1b1d0b09edf3d460db80b5d6aff904853d62e2ff38a75383b953a3bdf220550a",
    "logs": [],
    "blockNumber": 156184549,
    "cumulativeGasUsed": "502738",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 43,
  "solcInputHash": "d289ba9386e44c7d52c742087da38011",
  "metadata": "{\"compiler\":{\"version\":\"0.8.22+commit.4fc1097e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_payAmount\",\"type\":\"uint256\"}],\"name\":\"itemBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payAmount\",\"type\":\"uint256\"}],\"name\":\"pay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reFundAmount\",\"type\":\"uint256\"}],\"name\":\"reFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"ReentrancyGuardReentrantCall()\":[{\"details\":\"Unauthorized reentrant call.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/originforge/paymentFacet.sol\":\"PaymentFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0xf980daa263b661ab8ddee7d4fd833c7da7e7995e2c359ff1f17e67e4112f2236\",\"license\":\"MIT\"},\"contracts/originforge/paymentFacet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.22;\\n\\nimport {AppStorage} from \\\"../shared/storage/structs/AppStorage.sol\\\";\\nimport {IPoolRouter} from \\\"../shared/interfaces/IPoolRouter.sol\\\";\\nimport {LibMeta} from \\\"../shared/libraries/LibMeta.sol\\\";\\nimport {IERC20} from \\\"../shared/interfaces/IERC20.sol\\\";\\nimport {IERC1155} from \\\"../shared/interfaces/IERC1155.sol\\\";\\n//\\n//\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\ncontract PaymentFacet is ReentrancyGuard {\\n    AppStorage internal s;\\n    \\n    // address pageaRouter = address(0x17Ac28a29670e637c8a6E1ec32b38fC301303E34);\\n    // address gcPool = address(0x9F8a222Fd0b75239B32Aa8a97C30669E5981dB05);\\n    // address gcKlay = 0x999999999939ba65abb254339eec0b2a0dac80e9;\\n\\n    address gcPool;\\n    address pangeaRouter;\\n    address gcKlay;\\n    address bank;\\n\\n\\n    function pay(uint payAmount) external payable returns(uint,uint) {\\n        \\n       IPoolRouter poolRouter = IPoolRouter(pangeaRouter);\\n       IPoolRouter.ExactInputSingleParams memory params = IPoolRouter\\n            .ExactInputSingleParams({\\n                tokenIn: address(0),\\n                amountIn: payAmount,\\n                amountOutMinimum: payAmount,\\n                pool: gcPool,\\n                to: bank,\\n                unwrap: false\\n            });\\n\\n\\n        poolRouter.exactInputSingle{value: payAmount}(params);\\n\\n\\n        return (payAmount, block.number);\\n        \\n    }\\n    \\n    function reFund(\\n        address _sender,\\n        uint reFundAmount\\n    ) external nonReentrant returns (uint, uint) {\\n        // require(reFundAmount > 5 ether, \\\"LibPayment: reFundAmount too low\\\");\\n\\n        IPoolRouter poolRouter = IPoolRouter(pangeaRouter);\\n\\n        IPoolRouter.ExactInputSingleParams memory params = IPoolRouter\\n            .ExactInputSingleParams({\\n                tokenIn: gcKlay,\\n                amountIn: reFundAmount,\\n                amountOutMinimum: 10,\\n                pool: gcPool,\\n                to: _sender,\\n                unwrap: true\\n            });\\n\\n        poolRouter.exactInputSingle(params);\\n\\n        return (reFundAmount, block.number);\\n    }\\n\\n    function itemBuy(\\n        address _buyer,\\n        uint _itemId,\\n        uint _quantity,\\n        uint _payAmount\\n    ) external nonReentrant returns (uint, uint) {\\n        IERC1155 item = IERC1155(s.contracts[\\\"item\\\"]);\\n        uint itemPrice = s.items[_itemId].price * _quantity;\\n\\n        // require(s.items[_itemId].price != 0, \\\"PaymentFacet: item not found\\\");\\n        // require(_payAmount >= itemPrice, \\\"PaymentFacet: payAmount too low\\\");\\n\\n        IPoolRouter poolRouter = IPoolRouter(pangeaRouter);\\n\\n        IPoolRouter.ExactInputSingleParams memory params = IPoolRouter\\n            .ExactInputSingleParams({\\n                tokenIn: gcKlay,\\n                amountIn: itemPrice,\\n                amountOutMinimum: 10,\\n                pool: gcPool,\\n                to: bank,\\n                unwrap: true\\n            });\\n\\n        \\n        item.mint(_buyer, _itemId, _quantity, \\\"0x0\\\");\\n        \\n        poolRouter.exactInputSingle{value: itemPrice}(params);\\n\\n        return (itemPrice, block.number);\\n    }\\n}\\n\",\"keccak256\":\"0x6d86d2c13848fed30a83455abb03e7f8bd702c3c3fb5683a0218b64641d19331\",\"license\":\"UNLICENSED\"},\"contracts/shared/interfaces/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC1155 {\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function isApprovedForAll(\\n        address account,\\n        address operator\\n    ) external view returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n\\n    function burn(address account, uint256 id, uint256 value) external;\\n\\n    function balanceOf(\\n        address account,\\n        uint256 id\\n    ) external view returns (uint256);\\n\\n    function mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x681af62d301300542b9ebb9e2888763af9a053d3694a467c05700730cd4aceac\",\"license\":\"MIT\"},\"contracts/shared/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0xb1f741842fb81b560a48d0f336a76158be014fb7b3814b213a474c21f973a265\",\"license\":\"MIT\"},\"contracts/shared/interfaces/IPoolRouter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.8.0;\\n\\n/// @notice pool router interface.\\ninterface IPoolRouter {\\n    struct ExactInputSingleParams {\\n        address tokenIn; /// @dev the input token address. If tokenIn is address(0), msg.value will be wrapped and used as input token\\n        uint256 amountIn; /// @dev The amount of input tokens to send\\n        uint256 amountOutMinimum; /// @dev minimum required amount of output token after swap\\n        address pool; /// @dev pool address to swap\\n        address to; /// @dev address to receive\\n        bool unwrap; /// @dev unwrap if output token is wrapped klay\\n    }\\n\\n    struct ExactInputParams {\\n        address tokenIn; /// @dev the token address to swap-in. If tokenIn is address(0), msg.value will be wrapped and used as input token\\n        uint256 amountIn; /// @dev The amount of input tokens to send.\\n        uint256 amountOutMinimum; /// @dev minimum required amount of output token after swap\\n        address[] path; /// @dev An array of pool addresses to pass through\\n        address to; /// @dev recipient of the output tokens\\n        bool unwrap; /// @dev unwrap if output token is wrapped klay\\n    }\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn; /// @dev the input token address. If tokenIn is address(0), msg.value will be wrapped and used as input token\\n        uint256 amountOut; /// @dev The amount of output tokens to receive\\n        uint256 amountInMaximum; /// @dev maximum available amount of input token after swap\\n        address pool; /// @dev pool address to swap\\n        address to; /// @dev address to receive\\n        bool unwrap; /// @dev unwrap if output token is wrapped klay\\n    }\\n\\n    struct ExactOutputParams {\\n        address tokenIn; /// @dev the token address to swap-in. If tokenIn is address(0), msg.value will be wrapped and used as input token\\n        uint256 amountOut; /// @dev The amount of output tokens to receive\\n        uint256 amountInMaximum; /// @dev  maximum available amount of input token after swap\\n        address[] path; /// @dev An array of pool addresses to pass through\\n        address to; /// @dev recipient of the output tokens\\n        bool unwrap; /// @dev unwrap if output token is wrapped klay\\n    }\\n\\n    /// @notice Swap amountIn of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as ExactInputSingleParams in calldata\\n    function exactInputSingle(\\n        ExactInputSingleParams calldata params\\n    ) external payable returns (uint256 amountOut);\\n\\n    /// @notice Swap amountIn of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as ExactInputParams in calldata\\n    function exactInput(\\n        ExactInputParams calldata params\\n    ) external payable returns (uint256 amountOut);\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as ExactOutputSingleParams in calldata\\n    function exactOutputSingle(\\n        ExactOutputSingleParams calldata params\\n    ) external payable returns (uint256 amountIn);\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as ExactOutputParams in calldata\\n    function exactOutput(\\n        ExactOutputParams calldata params\\n    ) external payable returns (uint256 amountIn);\\n\\n    /// @notice Recover mistakenly sent tokens\\n    function sweep(\\n        address token,\\n        uint256 amount,\\n        address recipient\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0xfd0f120615ac739b8f0ebe4d126f0885b78480c4a9bcc1279994b45a7e17e8d9\",\"license\":\"GPL-3.0\"},\"contracts/shared/libraries/LibMeta.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\nlibrary LibMeta {\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\\n        keccak256(\\n            bytes(\\n                \\\"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\\\"\\n            )\\n        );\\n\\n    function domainSeparator(\\n        string memory name,\\n        string memory version\\n    ) internal view returns (bytes32 domainSeparator_) {\\n        domainSeparator_ = keccak256(\\n            abi.encode(\\n                EIP712_DOMAIN_TYPEHASH,\\n                keccak256(bytes(name)),\\n                keccak256(bytes(version)),\\n                getChainID(),\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function getChainID() internal view returns (uint256 id) {\\n        assembly {\\n            id := chainid()\\n        }\\n    }\\n\\n    function msgSender() internal view returns (address sender_) {\\n        if (msg.sender == address(this)) {\\n            bytes memory array = msg.data;\\n            uint256 index = msg.data.length;\\n            assembly {\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\n                sender_ := and(\\n                    mload(add(array, index)),\\n                    0xffffffffffffffffffffffffffffffffffffffff\\n                )\\n            }\\n        } else {\\n            sender_ = msg.sender;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x194f61daa9d3c92ca3de358b76506dbb1e9e39211dc5b49768f18cc38f85b1ab\",\"license\":\"MIT\"},\"contracts/shared/storage/structs/AppStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct User {\\n    string name;\\n    uint tokenId;\\n    //equpiment\\n    //inventory\\n    //stats\\n}\\n\\nstruct Item {\\n    uint itemId;\\n    uint price;\\n}\\n\\nstruct AppStorage {\\n    mapping(string => address) contracts;\\n    mapping(address => User) users;\\n    mapping(uint => Item) items;\\n}\\n\",\"keccak256\":\"0xfb0e1bfce9e764cbccaec67707081f9933a6fadb19ec74eaa6868c2d4adb4670\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506001600055610577806100256000396000f3fe6080604052600436106100345760003560e01c8063a3b544d914610039578063c290d69114610072578063e557498b14610085575b600080fd5b34801561004557600080fd5b50610059610054366004610430565b6100a5565b6040805192835260208301919091520160405180910390f35b610059610080366004610469565b61025d565b34801561009157600080fd5b506100596100a0366004610482565b610319565b6000806100b06103ea565b604051636974656d60e01b815260009060019060040190815260408051602092819003830190205460008981526003909352908220600101546001600160a01b0390911692506101019087906104ac565b6005546040805160c0810182526006546001600160a01b03908116825260208201859052600a8284015260048054821660608401526007548216608080850191909152600160a0850152935163731133e960e01b81528e831691810191909152602481018d9052604481018c90526064810193909352600360848401526203078360ec1b60a48401529394509183169285169063731133e99060c401600060405180830381600087803b1580156101b757600080fd5b505af11580156101cb573d6000803e3d6000fd5b505060405163603fae1960e11b81526001600160a01b038516925063c07f5c32915085906101fd9085906004016104d7565b60206040518083038185885af115801561021b573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906102409190610528565b509194504393505050506102546001600055565b94509492505050565b6005546040805160c081018252600080825260208201859052818301859052600480546001600160a01b0390811660608501526007548116608085015260a08401839052935163603fae1960e11b815291948594169291839163c07f5c329188916102ca918691016104d7565b60206040518083038185885af11580156102e8573d6000803e3d6000fd5b50505050506040513d601f19601f8201168201806040525081019061030d9190610528565b50939443945092505050565b6000806103246103ea565b6005546040805160c0810182526006546001600160a01b03908116825260208201879052600a8284015260048054821660608401528882166080840152600160a0840152925163603fae1960e11b81529316929091839163c07f5c329161038d918591016104d7565b6020604051808303816000875af11580156103ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103d09190610528565b5084439350935050506103e36001600055565b9250929050565b60026000540361040d57604051633ee5aeb560e01b815260040160405180910390fd5b6002600055565b80356001600160a01b038116811461042b57600080fd5b919050565b6000806000806080858703121561044657600080fd5b61044f85610414565b966020860135965060408601359560600135945092505050565b60006020828403121561047b57600080fd5b5035919050565b6000806040838503121561049557600080fd5b61049e83610414565b946020939093013593505050565b80820281158282048414176104d157634e487b7160e01b600052601160045260246000fd5b92915050565b81516001600160a01b03908116825260208084015190830152604080840151908301526060808401518216908301526080808401519091169082015260a09182015115159181019190915260c00190565b60006020828403121561053a57600080fd5b505191905056fea26469706673582212206a1928fd9d68393728a5d540ffba2827bc5c620a66b3630737e2481d4f12e95564736f6c63430008160033",
  "deployedBytecode": "0x6080604052600436106100345760003560e01c8063a3b544d914610039578063c290d69114610072578063e557498b14610085575b600080fd5b34801561004557600080fd5b50610059610054366004610430565b6100a5565b6040805192835260208301919091520160405180910390f35b610059610080366004610469565b61025d565b34801561009157600080fd5b506100596100a0366004610482565b610319565b6000806100b06103ea565b604051636974656d60e01b815260009060019060040190815260408051602092819003830190205460008981526003909352908220600101546001600160a01b0390911692506101019087906104ac565b6005546040805160c0810182526006546001600160a01b03908116825260208201859052600a8284015260048054821660608401526007548216608080850191909152600160a0850152935163731133e960e01b81528e831691810191909152602481018d9052604481018c90526064810193909352600360848401526203078360ec1b60a48401529394509183169285169063731133e99060c401600060405180830381600087803b1580156101b757600080fd5b505af11580156101cb573d6000803e3d6000fd5b505060405163603fae1960e11b81526001600160a01b038516925063c07f5c32915085906101fd9085906004016104d7565b60206040518083038185885af115801561021b573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906102409190610528565b509194504393505050506102546001600055565b94509492505050565b6005546040805160c081018252600080825260208201859052818301859052600480546001600160a01b0390811660608501526007548116608085015260a08401839052935163603fae1960e11b815291948594169291839163c07f5c329188916102ca918691016104d7565b60206040518083038185885af11580156102e8573d6000803e3d6000fd5b50505050506040513d601f19601f8201168201806040525081019061030d9190610528565b50939443945092505050565b6000806103246103ea565b6005546040805160c0810182526006546001600160a01b03908116825260208201879052600a8284015260048054821660608401528882166080840152600160a0840152925163603fae1960e11b81529316929091839163c07f5c329161038d918591016104d7565b6020604051808303816000875af11580156103ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103d09190610528565b5084439350935050506103e36001600055565b9250929050565b60026000540361040d57604051633ee5aeb560e01b815260040160405180910390fd5b6002600055565b80356001600160a01b038116811461042b57600080fd5b919050565b6000806000806080858703121561044657600080fd5b61044f85610414565b966020860135965060408601359560600135945092505050565b60006020828403121561047b57600080fd5b5035919050565b6000806040838503121561049557600080fd5b61049e83610414565b946020939093013593505050565b80820281158282048414176104d157634e487b7160e01b600052601160045260246000fd5b92915050565b81516001600160a01b03908116825260208084015190830152604080840151908301526060808401518216908301526080808401519091169082015260a09182015115159181019190915260c00190565b60006020828403121561053a57600080fd5b505191905056fea26469706673582212206a1928fd9d68393728a5d540ffba2827bc5c620a66b3630737e2481d4f12e95564736f6c63430008160033",
  "devdoc": {
    "errors": {
      "ReentrancyGuardReentrantCall()": [
        {
          "details": "Unauthorized reentrant call."
        }
      ]
    },
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 10,
        "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
        "label": "_status",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 86,
        "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
        "label": "s",
        "offset": 0,
        "slot": "1",
        "type": "t_struct(AppStorage)692_storage"
      },
      {
        "astId": 88,
        "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
        "label": "gcPool",
        "offset": 0,
        "slot": "4",
        "type": "t_address"
      },
      {
        "astId": 90,
        "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
        "label": "pangeaRouter",
        "offset": 0,
        "slot": "5",
        "type": "t_address"
      },
      {
        "astId": 92,
        "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
        "label": "gcKlay",
        "offset": 0,
        "slot": "6",
        "type": "t_address"
      },
      {
        "astId": 94,
        "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
        "label": "bank",
        "offset": 0,
        "slot": "7",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_struct(User)672_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct User)",
        "numberOfBytes": "32",
        "value": "t_struct(User)672_storage"
      },
      "t_mapping(t_string_memory_ptr,t_address)": {
        "encoding": "mapping",
        "key": "t_string_memory_ptr",
        "label": "mapping(string => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_struct(Item)677_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Item)",
        "numberOfBytes": "32",
        "value": "t_struct(Item)677_storage"
      },
      "t_string_memory_ptr": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(AppStorage)692_storage": {
        "encoding": "inplace",
        "label": "struct AppStorage",
        "members": [
          {
            "astId": 681,
            "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
            "label": "contracts",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_string_memory_ptr,t_address)"
          },
          {
            "astId": 686,
            "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
            "label": "users",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_address,t_struct(User)672_storage)"
          },
          {
            "astId": 691,
            "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
            "label": "items",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_uint256,t_struct(Item)677_storage)"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(Item)677_storage": {
        "encoding": "inplace",
        "label": "struct Item",
        "members": [
          {
            "astId": 674,
            "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
            "label": "itemId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 676,
            "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
            "label": "price",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(User)672_storage": {
        "encoding": "inplace",
        "label": "struct User",
        "members": [
          {
            "astId": 669,
            "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
            "label": "name",
            "offset": 0,
            "slot": "0",
            "type": "t_string_storage"
          },
          {
            "astId": 671,
            "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
            "label": "tokenId",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}