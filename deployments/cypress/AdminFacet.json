{
  "address": "0x768c58F98E90eaE2928018306ec46890AF5dfBEF",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        }
      ],
      "name": "AddressEmptyCode",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FailedInnerCall",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_itemId",
          "type": "uint256"
        }
      ],
      "name": "Admin_itemGet",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_itemId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_price",
          "type": "uint256"
        }
      ],
      "name": "Admin_itemSet",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_contractName",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "_contractAddress",
          "type": "address"
        }
      ],
      "name": "Admin_setContract",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_contractName",
          "type": "string"
        }
      ],
      "name": "getContract",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes[]",
          "name": "data",
          "type": "bytes[]"
        }
      ],
      "name": "multicall",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "results",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x402993429198a01d2c29dfa9d8d43523fbd6e3dee90d950a148ec545c299107d",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x78D851386840d7F70A68F2fBa538f54EBE2A5d8E",
    "contractAddress": null,
    "transactionIndex": 17,
    "gasUsed": "641580",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x8f7bb5dc9838ec3cfd5bc1b3e5dcfa9a2248de766a74f1fa25dcc3f95a9a1333",
    "transactionHash": "0x402993429198a01d2c29dfa9d8d43523fbd6e3dee90d950a148ec545c299107d",
    "logs": [],
    "blockNumber": 156091796,
    "cumulativeGasUsed": "10465565",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "1d5f1b9e7001dcbe09b38b982c366313",
  "metadata": "{\"compiler\":{\"version\":\"0.8.22+commit.4fc1097e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"Admin_itemGet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"Admin_itemSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_contractName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"Admin_setContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_contractName\",\"type\":\"string\"}],\"name\":\"getContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"AddressEmptyCode(address)\":[{\"details\":\"There's no code at `target` (it is not a contract).\"}],\"FailedInnerCall()\":[{\"details\":\"A call to an address target failed. The target may have reverted.\"}]},\"kind\":\"dev\",\"methods\":{\"multicall(bytes[])\":{\"custom:oz-upgrades-unsafe-allow-reachable\":\"delegatecall\",\"details\":\"Receives and executes a batch of function calls on this contract.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/openforge/adminFacet.sol\":\"AdminFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaf28a975a78550e45f65e559a3ad6a5ad43b9b8a37366999abd1b7084eb70721\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Multicall.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Multicall.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Address} from \\\"./Address.sol\\\";\\nimport {Context} from \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * Consider any assumption about calldata validation performed by the sender may be violated if it's not especially\\n * careful about sending transactions invoking {multicall}. For example, a relay address that filters function\\n * selectors won't filter calls nested within a {multicall} operation.\\n *\\n * NOTE: Since 5.0.1 and 4.9.4, this contract identifies non-canonical contexts (i.e. `msg.sender` is not {_msgSender}).\\n * If a non-canonical context is identified, the following self `delegatecall` appends the last bytes of `msg.data`\\n * to the subcall. This makes it safe to use with {ERC2771Context}. Contexts that don't affect the resolution of\\n * {_msgSender} are not propagated to subcalls.\\n */\\nabstract contract Multicall is Context {\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract.\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\\n        bytes memory context = msg.sender == _msgSender()\\n            ? new bytes(0)\\n            : msg.data[msg.data.length - _contextSuffixLength():];\\n\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = Address.functionDelegateCall(address(this), bytes.concat(data[i], context));\\n        }\\n        return results;\\n    }\\n}\\n\",\"keccak256\":\"0x8bbd8e639a2845206c2525c3e41892232a78372d952974bc1d2809b6879f6946\",\"license\":\"MIT\"},\"contracts/openforge/adminFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\nimport {AppStorage} from \\\"../shared/storage/structs/AppStorage.sol\\\";\\nimport {modifiersFacet} from \\\"../shared/utils/modifiersFacet.sol\\\";\\n// multicall \\ub77c\\uc774\\ube0c\\ub7ec\\ub9ac \\ucd94\\uac00\\nimport \\\"@openzeppelin/contracts/utils/Multicall.sol\\\";\\n\\ncontract AdminFacet is modifiersFacet, Multicall {\\n    AppStorage internal s;\\n\\n    function Admin_setContract(\\n        string memory _contractName,\\n        address _contractAddress\\n    ) external onlyAdmin {\\n        s.contracts[_contractName] = _contractAddress;\\n    }\\n\\n    function getContract(\\n        string memory _contractName\\n    ) external view returns (address) {\\n        return s.contracts[_contractName];\\n    }\\n\\n    function Admin_itemSet(uint _itemId, uint _price) external onlyAdmin {\\n        s.items[_itemId].itemId = _itemId;\\n        s.items[_itemId].price = _price;\\n    }\\n\\n    function Admin_itemGet(uint _itemId) external view returns (uint, uint) {\\n        return (s.items[_itemId].itemId, s.items[_itemId].price);\\n    }\\n}\\n\",\"keccak256\":\"0x1f08739be99b4d2c11ce31d209cd9a12aa86fa1b40ca555a0e8303f3fc884e98\",\"license\":\"MIT\"},\"contracts/shared/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0xc00c16bfa30a3fa5f3dc684f7f8ba62c259962b25f647d9588739458989717fc\",\"license\":\"MIT\"},\"contracts/shared/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            return;\\n        }\\n        enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");        \\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n        if (!success) {\\n            if (error.length > 0) {\\n                // bubble up error\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(error)\\n                    revert(add(32, error), returndata_size)\\n                }\\n            } else {\\n                revert InitializationFunctionReverted(_init, _calldata);\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x32804b629ea56692e6458dcaf1a4998c62ef289b071fe2690be171b25926f495\",\"license\":\"MIT\"},\"contracts/shared/storage/structs/AppStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct User {\\n    string name;\\n    uint tokenId;\\n    //equpiment\\n    //inventory\\n    //stats\\n}\\n\\nstruct Item {\\n    uint itemId;\\n    uint price;\\n}\\n\\nstruct AppStorage {\\n    mapping(string => address) contracts;\\n    mapping(address => User) users;\\n    mapping(uint => Item) items;\\n}\\n\",\"keccak256\":\"0xfb0e1bfce9e764cbccaec67707081f9933a6fadb19ec74eaa6868c2d4adb4670\",\"license\":\"MIT\"},\"contracts/shared/utils/modifiersFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\nimport {LibDiamond} from \\\"../libraries/LibDiamond.sol\\\";\\n\\ncontract modifiersFacet {\\n    \\n    modifier onlyAdmin() {\\n        LibDiamond.enforceIsContractOwner();\\n        _;\\n    }\\n\\n    \\n}\",\"keccak256\":\"0x5bdbd4705813f90779340b5e9454daf4d9a8607aa73d911708134db86a969297\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610790806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80632911a3661461005c578063358177731461009e578063ac9650d8146100c9578063bd8d6465146100e9578063d8f2daaa146100fe575b600080fd5b61008461006a366004610427565b600090815260026020526040902080546001909101549091565b604080519283526020830191909152015b60405180910390f35b6100b16100ac3660046104e3565b610111565b6040516001600160a01b039091168152602001610095565b6100dc6100d7366004610520565b610144565b60405161009591906105b9565b6100fc6100f7366004610633565b61022c565b005b6100fc61010c366004610655565b61024d565b6000806000018260405161012591906106b3565b908152604051908190036020019020546001600160a01b031692915050565b6040805160008152602081019091526060908267ffffffffffffffff81111561016f5761016f610440565b6040519080825280602002602001820160405280156101a257816020015b606081526020019060019003908161018d5790505b50915060005b83811015610224576101ff308686848181106101c6576101c66106cf565b90506020028101906101d891906106e5565b856040516020016101eb93929190610733565b60405160208183030381529060405261029b565b838281518110610211576102116106cf565b60209081029190910101526001016101a8565b505092915050565b610234610311565b6000828152600260205260409020918255600190910155565b610255610311565b80600080018360405161026891906106b3565b90815260405190819003602001902080546001600160a01b03929092166001600160a01b03199092169190911790555050565b6060600080846001600160a01b0316846040516102b891906106b3565b600060405180830381855af49150503d80600081146102f3576040519150601f19603f3d011682016040523d82523d6000602084013e6102f8565b606091505b509150915061030885838361039f565b95945050505050565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c600401546001600160a01b0316331461039d5760405162461bcd60e51b815260206004820152602260248201527f4c69624469616d6f6e643a204d75737420626520636f6e7472616374206f776e60448201526132b960f11b60648201526084015b60405180910390fd5b565b6060826103b4576103af826103fe565b6103f7565b81511580156103cb57506001600160a01b0384163b155b156103f457604051639996b31560e01b81526001600160a01b0385166004820152602401610394565b50805b9392505050565b80511561040e5780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b60006020828403121561043957600080fd5b5035919050565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261046757600080fd5b813567ffffffffffffffff8082111561048257610482610440565b604051601f8301601f19908116603f011681019082821181831017156104aa576104aa610440565b816040528381528660208588010111156104c357600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000602082840312156104f557600080fd5b813567ffffffffffffffff81111561050c57600080fd5b61051884828501610456565b949350505050565b6000806020838503121561053357600080fd5b823567ffffffffffffffff8082111561054b57600080fd5b818501915085601f83011261055f57600080fd5b81358181111561056e57600080fd5b8660208260051b850101111561058357600080fd5b60209290920196919550909350505050565b60005b838110156105b0578181015183820152602001610598565b50506000910152565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b8281101561062657878503603f1901845281518051808752610607818989018a8501610595565b601f01601f1916959095018601945092850192908501906001016105e0565b5092979650505050505050565b6000806040838503121561064657600080fd5b50508035926020909101359150565b6000806040838503121561066857600080fd5b823567ffffffffffffffff81111561067f57600080fd5b61068b85828601610456565b92505060208301356001600160a01b03811681146106a857600080fd5b809150509250929050565b600082516106c5818460208701610595565b9190910192915050565b634e487b7160e01b600052603260045260246000fd5b6000808335601e198436030181126106fc57600080fd5b83018035915067ffffffffffffffff82111561071757600080fd5b60200191503681900382131561072c57600080fd5b9250929050565b828482376000838201600081528351610750818360208801610595565b019594505050505056fea26469706673582212202f4694c9593806a8b2eba149ad03543a6fba8858c7c9b19762c7efec474cee6c64736f6c63430008160033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c80632911a3661461005c578063358177731461009e578063ac9650d8146100c9578063bd8d6465146100e9578063d8f2daaa146100fe575b600080fd5b61008461006a366004610427565b600090815260026020526040902080546001909101549091565b604080519283526020830191909152015b60405180910390f35b6100b16100ac3660046104e3565b610111565b6040516001600160a01b039091168152602001610095565b6100dc6100d7366004610520565b610144565b60405161009591906105b9565b6100fc6100f7366004610633565b61022c565b005b6100fc61010c366004610655565b61024d565b6000806000018260405161012591906106b3565b908152604051908190036020019020546001600160a01b031692915050565b6040805160008152602081019091526060908267ffffffffffffffff81111561016f5761016f610440565b6040519080825280602002602001820160405280156101a257816020015b606081526020019060019003908161018d5790505b50915060005b83811015610224576101ff308686848181106101c6576101c66106cf565b90506020028101906101d891906106e5565b856040516020016101eb93929190610733565b60405160208183030381529060405261029b565b838281518110610211576102116106cf565b60209081029190910101526001016101a8565b505092915050565b610234610311565b6000828152600260205260409020918255600190910155565b610255610311565b80600080018360405161026891906106b3565b90815260405190819003602001902080546001600160a01b03929092166001600160a01b03199092169190911790555050565b6060600080846001600160a01b0316846040516102b891906106b3565b600060405180830381855af49150503d80600081146102f3576040519150601f19603f3d011682016040523d82523d6000602084013e6102f8565b606091505b509150915061030885838361039f565b95945050505050565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c600401546001600160a01b0316331461039d5760405162461bcd60e51b815260206004820152602260248201527f4c69624469616d6f6e643a204d75737420626520636f6e7472616374206f776e60448201526132b960f11b60648201526084015b60405180910390fd5b565b6060826103b4576103af826103fe565b6103f7565b81511580156103cb57506001600160a01b0384163b155b156103f457604051639996b31560e01b81526001600160a01b0385166004820152602401610394565b50805b9392505050565b80511561040e5780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b60006020828403121561043957600080fd5b5035919050565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261046757600080fd5b813567ffffffffffffffff8082111561048257610482610440565b604051601f8301601f19908116603f011681019082821181831017156104aa576104aa610440565b816040528381528660208588010111156104c357600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000602082840312156104f557600080fd5b813567ffffffffffffffff81111561050c57600080fd5b61051884828501610456565b949350505050565b6000806020838503121561053357600080fd5b823567ffffffffffffffff8082111561054b57600080fd5b818501915085601f83011261055f57600080fd5b81358181111561056e57600080fd5b8660208260051b850101111561058357600080fd5b60209290920196919550909350505050565b60005b838110156105b0578181015183820152602001610598565b50506000910152565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b8281101561062657878503603f1901845281518051808752610607818989018a8501610595565b601f01601f1916959095018601945092850192908501906001016105e0565b5092979650505050505050565b6000806040838503121561064657600080fd5b50508035926020909101359150565b6000806040838503121561066857600080fd5b823567ffffffffffffffff81111561067f57600080fd5b61068b85828601610456565b92505060208301356001600160a01b03811681146106a857600080fd5b809150509250929050565b600082516106c5818460208701610595565b9190910192915050565b634e487b7160e01b600052603260045260246000fd5b6000808335601e198436030181126106fc57600080fd5b83018035915067ffffffffffffffff82111561071757600080fd5b60200191503681900382131561072c57600080fd5b9250929050565b828482376000838201600081528351610750818360208801610595565b019594505050505056fea26469706673582212202f4694c9593806a8b2eba149ad03543a6fba8858c7c9b19762c7efec474cee6c64736f6c63430008160033",
  "devdoc": {
    "errors": {
      "AddressEmptyCode(address)": [
        {
          "details": "There's no code at `target` (it is not a contract)."
        }
      ],
      "FailedInnerCall()": [
        {
          "details": "A call to an address target failed. The target may have reverted."
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "multicall(bytes[])": {
        "custom:oz-upgrades-unsafe-allow-reachable": "delegatecall",
        "details": "Receives and executes a batch of function calls on this contract."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 452,
        "contract": "contracts/openforge/adminFacet.sol:AdminFacet",
        "label": "s",
        "offset": 0,
        "slot": "0",
        "type": "t_struct(AppStorage)2056_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_struct(User)2036_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct User)",
        "numberOfBytes": "32",
        "value": "t_struct(User)2036_storage"
      },
      "t_mapping(t_string_memory_ptr,t_address)": {
        "encoding": "mapping",
        "key": "t_string_memory_ptr",
        "label": "mapping(string => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_struct(Item)2041_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Item)",
        "numberOfBytes": "32",
        "value": "t_struct(Item)2041_storage"
      },
      "t_string_memory_ptr": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(AppStorage)2056_storage": {
        "encoding": "inplace",
        "label": "struct AppStorage",
        "members": [
          {
            "astId": 2045,
            "contract": "contracts/openforge/adminFacet.sol:AdminFacet",
            "label": "contracts",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_string_memory_ptr,t_address)"
          },
          {
            "astId": 2050,
            "contract": "contracts/openforge/adminFacet.sol:AdminFacet",
            "label": "users",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_address,t_struct(User)2036_storage)"
          },
          {
            "astId": 2055,
            "contract": "contracts/openforge/adminFacet.sol:AdminFacet",
            "label": "items",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_uint256,t_struct(Item)2041_storage)"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(Item)2041_storage": {
        "encoding": "inplace",
        "label": "struct Item",
        "members": [
          {
            "astId": 2038,
            "contract": "contracts/openforge/adminFacet.sol:AdminFacet",
            "label": "itemId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 2040,
            "contract": "contracts/openforge/adminFacet.sol:AdminFacet",
            "label": "price",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(User)2036_storage": {
        "encoding": "inplace",
        "label": "struct User",
        "members": [
          {
            "astId": 2033,
            "contract": "contracts/openforge/adminFacet.sol:AdminFacet",
            "label": "name",
            "offset": 0,
            "slot": "0",
            "type": "t_string_storage"
          },
          {
            "astId": 2035,
            "contract": "contracts/openforge/adminFacet.sol:AdminFacet",
            "label": "tokenId",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}