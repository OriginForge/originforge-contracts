{
  "address": "0x725E0fd188B1C9B2ff64F9f33BD1b16Cc8F92377",
  "abi": [
    {
      "inputs": [],
      "name": "ReentrancyGuardReentrantCall",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "payAmount",
          "type": "uint256"
        }
      ],
      "name": "pay",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_sender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "reFundAmount",
          "type": "uint256"
        }
      ],
      "name": "reFund",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x1b9f38e1d0459c85b3e7fc7901b3a3eff9d2cbe7510fd444fdadeeb1295b217d",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x78D851386840d7F70A68F2fBa538f54EBE2A5d8E",
    "contractAddress": null,
    "transactionIndex": 8,
    "gasUsed": "481698",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x576043c8176a91f8cbacb52de1c17bc475f55d7f0880da56a9f38eb294f60d83",
    "transactionHash": "0x1b9f38e1d0459c85b3e7fc7901b3a3eff9d2cbe7510fd444fdadeeb1295b217d",
    "logs": [],
    "blockNumber": 156457790,
    "cumulativeGasUsed": "1343533",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 44,
  "solcInputHash": "28981b9602cc1820c8fd4b0712cd8837",
  "metadata": "{\"compiler\":{\"version\":\"0.8.22+commit.4fc1097e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payAmount\",\"type\":\"uint256\"}],\"name\":\"pay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reFundAmount\",\"type\":\"uint256\"}],\"name\":\"reFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"ReentrancyGuardReentrantCall()\":[{\"details\":\"Unauthorized reentrant call.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/originforge/paymentFacet.sol\":\"PaymentFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0xf980daa263b661ab8ddee7d4fd833c7da7e7995e2c359ff1f17e67e4112f2236\",\"license\":\"MIT\"},\"contracts/originforge/paymentFacet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.22;\\n\\nimport {AppStorage} from \\\"../shared/storage/structs/AppStorage.sol\\\";\\nimport {IPoolRouter} from \\\"../shared/interfaces/IPoolRouter.sol\\\";\\nimport {LibMeta} from \\\"../shared/libraries/LibMeta.sol\\\";\\nimport {IERC20} from \\\"../shared/interfaces/IERC20.sol\\\";\\nimport {IERC1155} from \\\"../shared/interfaces/IERC1155.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\ncontract PaymentFacet is ReentrancyGuard {\\n    AppStorage internal s;\\n\\n    // address pageaRouter = address(0x17Ac28a29670e637c8a6E1ec32b38fC301303E34);\\n    // address gcPool = address(0x9F8a222Fd0b75239B32Aa8a97C30669E5981dB05);\\n    // address gcKlay = 0x999999999939ba65abb254339eec0b2a0dac80e9;\\n\\n    address gcPool;\\n    address pangeaRouter;\\n    address gcKlay;\\n    address bank;\\n    \\n    function pay(uint payAmount) external payable returns (uint) {\\n        IERC20 token = IERC20(gcKlay);\\n        IPoolRouter poolRouter = IPoolRouter(pangeaRouter);\\n        IPoolRouter.ExactInputSingleParams memory params = IPoolRouter\\n            .ExactInputSingleParams({\\n                tokenIn: address(0),\\n                amountIn: payAmount,\\n                amountOutMinimum: payAmount,\\n                pool: gcPool,\\n                to: address(this),\\n                unwrap: false\\n            });\\n\\n        poolRouter.exactInputSingle{value: payAmount}(params);\\n        uint swapBalance = token.balanceOf(address(this));\\n        (uint caluledAmount, uint fee) = _feeCalculation(swapBalance);\\n        \\n        token.transfer(bank, fee);\\n        token.transfer(msg.sender, caluledAmount);\\n\\n        return (caluledAmount);\\n    }\\n\\n    function reFund(\\n        address _sender,\\n        uint reFundAmount\\n    ) external nonReentrant returns (uint, uint) {\\n        // require(reFundAmount > 5 ether, \\\"LibPayment: reFundAmount too low\\\");\\n\\n        IPoolRouter poolRouter = IPoolRouter(pangeaRouter);\\n\\n        IPoolRouter.ExactInputSingleParams memory params = IPoolRouter\\n            .ExactInputSingleParams({\\n                tokenIn: gcKlay,\\n                amountIn: reFundAmount,\\n                amountOutMinimum: 10,\\n                pool: gcPool,\\n                to: _sender,\\n                unwrap: true\\n            });\\n\\n        poolRouter.exactInputSingle(params);\\n\\n        return (reFundAmount, block.number);\\n    }\\n\\n    function _feeCalculation(\\n        uint256 _amount\\n    ) internal view returns (uint256, uint256) {\\n        uint256 fee = _amount / 100;\\n        return (_amount - fee, fee);\\n    }\\n    // function itemBuy(\\n    //     address _buyer,\\n    //     uint _itemId,\\n    //     uint _quantity,\\n    //     uint _payAmount\\n    // ) external nonReentrant returns (uint, uint) {\\n    //     IERC1155 item = IERC1155(s.contracts[\\\"item\\\"]);\\n    //     uint itemPrice = s.items[_itemId].price * _quantity;\\n\\n    //     // require(s.items[_itemId].price != 0, \\\"PaymentFacet: item not found\\\");\\n    //     // require(_payAmount >= itemPrice, \\\"PaymentFacet: payAmount too low\\\");\\n\\n    //     IPoolRouter poolRouter = IPoolRouter(pangeaRouter);\\n\\n    //     IPoolRouter.ExactInputSingleParams memory params = IPoolRouter\\n    //         .ExactInputSingleParams({\\n    //             tokenIn: gcKlay,\\n    //             amountIn: itemPrice,\\n    //             amountOutMinimum: 10,\\n    //             pool: gcPool,\\n    //             to: bank,\\n    //             unwrap: true\\n    //         });\\n\\n    //     item.mint(_buyer, _itemId, _quantity, \\\"0x0\\\");\\n\\n    //     poolRouter.exactInputSingle{value: itemPrice}(params);\\n\\n    //     return (itemPrice, block.number);\\n    // }\\n}\\n\",\"keccak256\":\"0xba9443f240bf9b37807896de40f43a40c78331b2d6bd40db2090ddec6988be98\",\"license\":\"UNLICENSED\"},\"contracts/shared/interfaces/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC1155 {\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function isApprovedForAll(\\n        address account,\\n        address operator\\n    ) external view returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n\\n    function burn(address account, uint256 id, uint256 value) external;\\n\\n    function balanceOf(\\n        address account,\\n        uint256 id\\n    ) external view returns (uint256);\\n\\n    function mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x681af62d301300542b9ebb9e2888763af9a053d3694a467c05700730cd4aceac\",\"license\":\"MIT\"},\"contracts/shared/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0xb1f741842fb81b560a48d0f336a76158be014fb7b3814b213a474c21f973a265\",\"license\":\"MIT\"},\"contracts/shared/interfaces/IPoolRouter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.8.0;\\n\\n/// @notice pool router interface.\\ninterface IPoolRouter {\\n    struct ExactInputSingleParams {\\n        address tokenIn; /// @dev the input token address. If tokenIn is address(0), msg.value will be wrapped and used as input token\\n        uint256 amountIn; /// @dev The amount of input tokens to send\\n        uint256 amountOutMinimum; /// @dev minimum required amount of output token after swap\\n        address pool; /// @dev pool address to swap\\n        address to; /// @dev address to receive\\n        bool unwrap; /// @dev unwrap if output token is wrapped klay\\n    }\\n\\n    struct ExactInputParams {\\n        address tokenIn; /// @dev the token address to swap-in. If tokenIn is address(0), msg.value will be wrapped and used as input token\\n        uint256 amountIn; /// @dev The amount of input tokens to send.\\n        uint256 amountOutMinimum; /// @dev minimum required amount of output token after swap\\n        address[] path; /// @dev An array of pool addresses to pass through\\n        address to; /// @dev recipient of the output tokens\\n        bool unwrap; /// @dev unwrap if output token is wrapped klay\\n    }\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn; /// @dev the input token address. If tokenIn is address(0), msg.value will be wrapped and used as input token\\n        uint256 amountOut; /// @dev The amount of output tokens to receive\\n        uint256 amountInMaximum; /// @dev maximum available amount of input token after swap\\n        address pool; /// @dev pool address to swap\\n        address to; /// @dev address to receive\\n        bool unwrap; /// @dev unwrap if output token is wrapped klay\\n    }\\n\\n    struct ExactOutputParams {\\n        address tokenIn; /// @dev the token address to swap-in. If tokenIn is address(0), msg.value will be wrapped and used as input token\\n        uint256 amountOut; /// @dev The amount of output tokens to receive\\n        uint256 amountInMaximum; /// @dev  maximum available amount of input token after swap\\n        address[] path; /// @dev An array of pool addresses to pass through\\n        address to; /// @dev recipient of the output tokens\\n        bool unwrap; /// @dev unwrap if output token is wrapped klay\\n    }\\n\\n    /// @notice Swap amountIn of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as ExactInputSingleParams in calldata\\n    function exactInputSingle(\\n        ExactInputSingleParams calldata params\\n    ) external payable returns (uint256 amountOut);\\n\\n    /// @notice Swap amountIn of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as ExactInputParams in calldata\\n    function exactInput(\\n        ExactInputParams calldata params\\n    ) external payable returns (uint256 amountOut);\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as ExactOutputSingleParams in calldata\\n    function exactOutputSingle(\\n        ExactOutputSingleParams calldata params\\n    ) external payable returns (uint256 amountIn);\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as ExactOutputParams in calldata\\n    function exactOutput(\\n        ExactOutputParams calldata params\\n    ) external payable returns (uint256 amountIn);\\n\\n    /// @notice Recover mistakenly sent tokens\\n    function sweep(\\n        address token,\\n        uint256 amount,\\n        address recipient\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0xfd0f120615ac739b8f0ebe4d126f0885b78480c4a9bcc1279994b45a7e17e8d9\",\"license\":\"GPL-3.0\"},\"contracts/shared/libraries/LibMeta.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\nlibrary LibMeta {\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\\n        keccak256(\\n            bytes(\\n                \\\"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\\\"\\n            )\\n        );\\n\\n    function domainSeparator(\\n        string memory name,\\n        string memory version\\n    ) internal view returns (bytes32 domainSeparator_) {\\n        domainSeparator_ = keccak256(\\n            abi.encode(\\n                EIP712_DOMAIN_TYPEHASH,\\n                keccak256(bytes(name)),\\n                keccak256(bytes(version)),\\n                getChainID(),\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function getChainID() internal view returns (uint256 id) {\\n        assembly {\\n            id := chainid()\\n        }\\n    }\\n\\n    function msgSender() internal view returns (address sender_) {\\n        if (msg.sender == address(this)) {\\n            bytes memory array = msg.data;\\n            uint256 index = msg.data.length;\\n            assembly {\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\n                sender_ := and(\\n                    mload(add(array, index)),\\n                    0xffffffffffffffffffffffffffffffffffffffff\\n                )\\n            }\\n        } else {\\n            sender_ = msg.sender;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x194f61daa9d3c92ca3de358b76506dbb1e9e39211dc5b49768f18cc38f85b1ab\",\"license\":\"MIT\"},\"contracts/shared/storage/structs/AppStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct User {\\n    string name;\\n    uint tokenId;\\n    //equpiment\\n    //inventory\\n    //stats\\n}\\n\\nstruct Item {\\n    uint itemId;\\n    uint price;\\n}\\n\\nstruct AppStorage {\\n    mapping(string => address) contracts;\\n    mapping(address => User) users;\\n    mapping(uint => Item) items;\\n}\\n\",\"keccak256\":\"0xfb0e1bfce9e764cbccaec67707081f9933a6fadb19ec74eaa6868c2d4adb4670\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506001600055610531806100256000396000f3fe6080604052600436106100295760003560e01c8063c290d6911461002e578063e557498b14610054575b600080fd5b61004161003c3660046103ce565b610089565b6040519081526020015b60405180910390f35b34801561006057600080fd5b5061007461006f3660046103e7565b6102af565b6040805192835260208301919091520161004b565b6006546005546040805160c081018252600080825260208201869052818301869052600480546001600160a01b03908116606085015230608085015260a08401839052935163603fae1960e11b8152919584169490931692839163c07f5c329188916100f79186910161041f565b60206040518083038185885af1158015610115573d6000803e3d6000fd5b50505050506040513d601f19601f8201168201806040525081019061013a9190610470565b506040516370a0823160e01b81523060048201526000906001600160a01b038516906370a0823190602401602060405180830381865afa158015610182573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101a69190610470565b90506000806101b483610380565b60075460405163a9059cbb60e01b81526001600160a01b0391821660048201526024810183905292945090925087169063a9059cbb906044016020604051808303816000875af115801561020c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102309190610489565b5060405163a9059cbb60e01b8152336004820152602481018390526001600160a01b0387169063a9059cbb906044016020604051808303816000875af115801561027e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102a29190610489565b5090979650505050505050565b6000806102ba6103a4565b6005546040805160c0810182526006546001600160a01b03908116825260208201879052600a8284015260048054821660608401528882166080840152600160a0840152925163603fae1960e11b81529316929091839163c07f5c32916103239185910161041f565b6020604051808303816000875af1158015610342573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103669190610470565b5084439350935050506103796001600055565b9250929050565b6000808061038f6064856104b2565b905061039b81856104d4565b94909350915050565b6002600054036103c757604051633ee5aeb560e01b815260040160405180910390fd5b6002600055565b6000602082840312156103e057600080fd5b5035919050565b600080604083850312156103fa57600080fd5b82356001600160a01b038116811461041157600080fd5b946020939093013593505050565b81516001600160a01b03908116825260208084015190830152604080840151908301526060808401518216908301526080808401519091169082015260a09182015115159181019190915260c00190565b60006020828403121561048257600080fd5b5051919050565b60006020828403121561049b57600080fd5b815180151581146104ab57600080fd5b9392505050565b6000826104cf57634e487b7160e01b600052601260045260246000fd5b500490565b818103818111156104f557634e487b7160e01b600052601160045260246000fd5b9291505056fea26469706673582212205c6d5a810c304677c5c293217072817b5b36fd5f6755fca1d16430371d11a9d464736f6c63430008160033",
  "deployedBytecode": "0x6080604052600436106100295760003560e01c8063c290d6911461002e578063e557498b14610054575b600080fd5b61004161003c3660046103ce565b610089565b6040519081526020015b60405180910390f35b34801561006057600080fd5b5061007461006f3660046103e7565b6102af565b6040805192835260208301919091520161004b565b6006546005546040805160c081018252600080825260208201869052818301869052600480546001600160a01b03908116606085015230608085015260a08401839052935163603fae1960e11b8152919584169490931692839163c07f5c329188916100f79186910161041f565b60206040518083038185885af1158015610115573d6000803e3d6000fd5b50505050506040513d601f19601f8201168201806040525081019061013a9190610470565b506040516370a0823160e01b81523060048201526000906001600160a01b038516906370a0823190602401602060405180830381865afa158015610182573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101a69190610470565b90506000806101b483610380565b60075460405163a9059cbb60e01b81526001600160a01b0391821660048201526024810183905292945090925087169063a9059cbb906044016020604051808303816000875af115801561020c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102309190610489565b5060405163a9059cbb60e01b8152336004820152602481018390526001600160a01b0387169063a9059cbb906044016020604051808303816000875af115801561027e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102a29190610489565b5090979650505050505050565b6000806102ba6103a4565b6005546040805160c0810182526006546001600160a01b03908116825260208201879052600a8284015260048054821660608401528882166080840152600160a0840152925163603fae1960e11b81529316929091839163c07f5c32916103239185910161041f565b6020604051808303816000875af1158015610342573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103669190610470565b5084439350935050506103796001600055565b9250929050565b6000808061038f6064856104b2565b905061039b81856104d4565b94909350915050565b6002600054036103c757604051633ee5aeb560e01b815260040160405180910390fd5b6002600055565b6000602082840312156103e057600080fd5b5035919050565b600080604083850312156103fa57600080fd5b82356001600160a01b038116811461041157600080fd5b946020939093013593505050565b81516001600160a01b03908116825260208084015190830152604080840151908301526060808401518216908301526080808401519091169082015260a09182015115159181019190915260c00190565b60006020828403121561048257600080fd5b5051919050565b60006020828403121561049b57600080fd5b815180151581146104ab57600080fd5b9392505050565b6000826104cf57634e487b7160e01b600052601260045260246000fd5b500490565b818103818111156104f557634e487b7160e01b600052601160045260246000fd5b9291505056fea26469706673582212205c6d5a810c304677c5c293217072817b5b36fd5f6755fca1d16430371d11a9d464736f6c63430008160033",
  "devdoc": {
    "errors": {
      "ReentrancyGuardReentrantCall()": [
        {
          "details": "Unauthorized reentrant call."
        }
      ]
    },
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 4423,
        "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
        "label": "_status",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 10059,
        "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
        "label": "s",
        "offset": 0,
        "slot": "1",
        "type": "t_struct(AppStorage)10644_storage"
      },
      {
        "astId": 10061,
        "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
        "label": "gcPool",
        "offset": 0,
        "slot": "4",
        "type": "t_address"
      },
      {
        "astId": 10063,
        "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
        "label": "pangeaRouter",
        "offset": 0,
        "slot": "5",
        "type": "t_address"
      },
      {
        "astId": 10065,
        "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
        "label": "gcKlay",
        "offset": 0,
        "slot": "6",
        "type": "t_address"
      },
      {
        "astId": 10067,
        "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
        "label": "bank",
        "offset": 0,
        "slot": "7",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_struct(User)10624_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct User)",
        "numberOfBytes": "32",
        "value": "t_struct(User)10624_storage"
      },
      "t_mapping(t_string_memory_ptr,t_address)": {
        "encoding": "mapping",
        "key": "t_string_memory_ptr",
        "label": "mapping(string => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_struct(Item)10629_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Item)",
        "numberOfBytes": "32",
        "value": "t_struct(Item)10629_storage"
      },
      "t_string_memory_ptr": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(AppStorage)10644_storage": {
        "encoding": "inplace",
        "label": "struct AppStorage",
        "members": [
          {
            "astId": 10633,
            "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
            "label": "contracts",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_string_memory_ptr,t_address)"
          },
          {
            "astId": 10638,
            "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
            "label": "users",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_address,t_struct(User)10624_storage)"
          },
          {
            "astId": 10643,
            "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
            "label": "items",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_uint256,t_struct(Item)10629_storage)"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(Item)10629_storage": {
        "encoding": "inplace",
        "label": "struct Item",
        "members": [
          {
            "astId": 10626,
            "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
            "label": "itemId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 10628,
            "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
            "label": "price",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(User)10624_storage": {
        "encoding": "inplace",
        "label": "struct User",
        "members": [
          {
            "astId": 10621,
            "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
            "label": "name",
            "offset": 0,
            "slot": "0",
            "type": "t_string_storage"
          },
          {
            "astId": 10623,
            "contract": "contracts/originforge/paymentFacet.sol:PaymentFacet",
            "label": "tokenId",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}